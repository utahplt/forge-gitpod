#lang racket/base

(require forge/sigs-structs)
(require forge/breaks)
(require forge/lang/ast)
(require forge/lang/bounds)
(require forge/shared
         (prefix-in tree: forge/lazy-tree)
         forge/last-checker
         forge/choose-lang-specific
         forge/translate-to-kodkod-cli
         forge/translate-from-kodkod-cli)
(require (prefix-in @ (only-in racket/base >= not - = and or max > <))
         (only-in racket match first rest empty empty? set->list list->set set-intersect set-union
                         curry range index-of pretty-print filter-map string-prefix? thunk*
                         remove-duplicates subset? cartesian-product match-define cons?)
          racket/hash)
(require (only-in syntax/srcloc build-source-location-syntax))
(require (prefix-in pardinus: forge/pardinus-cli/server/kks)
         (prefix-in pardinus: forge/pardinus-cli/server/server)
         (prefix-in pardinus: forge/pardinus-cli/server/server-common))

; Disable DrRacket GUI extension/tool
;(require "drracket-gui.rkt")

(provide send-to-kodkod)

(define no-version-printed-yet #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;    Run Logic    ;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Will be a Server-ports tuple if a server is active. 
(define server-state (box #f))

; send-to-kodkod :: Run-spec -> Stream<model>, List<Symbol>
; Given a Run-spec structure, processes the data and communicates it to KodKod-CLI;
; then produces a stream to produce instances generated by KodKod, 
; along with a list of all of the atom names for sig atoms.
(define (send-to-kodkod run-spec run-command #:run-name [run-name (gensym)])
  (do-time "send-to-kodkod")
  ; In case of error, highlight an AST node if able. Otherwise, focus on the offending run command.
  (define (raise-run-error message [node #f])
    (if node
        (raise-syntax-error #f message
                            (datum->syntax #f (build-source-location-syntax (nodeinfo-loc (node-info node)))))
        (raise-syntax-error #f message run-command)))

  ; Print version number, so students know to update
  (when (and no-version-printed-yet (@>= (get-verbosity) VERBOSITY_LOW))
    (set! no-version-printed-yet #f)
    (printf "Forge version: ~a~n" forge-version)
    (let ([git-info (forge-git-info)])
      (when (pair? git-info)
        (apply printf " branch: ~a~n commit: ~a~n timestamp: ~a~n" git-info)))
    (printf "To report issues with Forge, please visit ~a~n"
            "https://report.forge-fm.org"))
  
  ; Do relation breaks from declarations
  (define relation-constraints 
    (apply append
           (for/list ([relation (get-relations run-spec)])
             (match (Relation-breaker relation)
               [#f (list)]
               ['default (list)]
               ['pfunc (let* ([rel relation]
                              [sigs (map (lambda (sig-thunk) (sig-thunk))
                                         (Relation-sigs-thunks relation))]
                              [left-sig (get-sig run-spec (first sigs))]
                              [sig-rel left-sig])
                         (list (all ([s sig-rel])
                                 (lone (join s rel)))))]
               [other (break relation other)
                      (list)]))))

  (define-values (sig-to-bound relation-to-bound all-atoms)
    (get-bounds run-spec raise-run-error))

  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get new bounds and constraints from breaks
  (define-values (total-bounds break-preds)
    (let* ([sig-bounds (map (compose (curry hash-ref sig-to-bound )
                                     Sig-name)
                            (get-sigs run-spec))]
           [relation-bounds (map (compose (curry hash-ref relation-to-bound )
                                          Relation-name)
                                 (get-relations run-spec))]
           [total-bounds (append sig-bounds relation-bounds)]

           [sigs (get-sigs run-spec)]
           [sig-rels (filter (lambda (sig) (@not (equal? (Sig-name sig) 'Int))) sigs)]
           [upper-bounds (for/hash ([sig sigs]) 
                           (values sig
                                   (map car (bound-upper (hash-ref sig-to-bound (Sig-name sig))))))]
           [relations-store (for/hash ([relation (get-relations run-spec)]
                                       #:unless (equal? (Relation-name relation) 'succ))
                              (values relation (get-sigs run-spec relation)))]
           [extensions-store (for/hash ([sig sigs]
                                        #:when (Sig-extends sig))
                               (values sig (get-sig run-spec (Sig-extends sig))))])
      ;(printf "args-- total-bounds : ~a~n args-- sig-rels : ~a~n args-- upper-bounds : ~a~n" total-bounds sig-rels upper-bounds )
      (constrain-bounds total-bounds sig-rels upper-bounds relations-store extensions-store)))
  ;(printf "after-- total-bounds : ~a~n" total-bounds)
  (clear-breaker-state)

  (define sigs-and-rels
    (append (State-sig-order (Run-spec-state run-spec))
            (State-relation-order (Run-spec-state run-spec))))
  (set! total-bounds (map (lambda (name) 
                            (findf (lambda (b) 
                                     (equal? name (string->symbol (relation-name (bound-relation b)))))
                                   total-bounds)) 
                          sigs-and-rels))

  (when (@>= (get-verbosity) VERBOSITY_DEBUG)
    (displayln "--------------------------")
    (printf "Original PBindings: ~n~a~n~n" (Bound-pbindings (Run-spec-bounds run-spec)))
    (printf "sig-to-bound: ~n~a~n~n" sig-to-bound)
    (printf "relation-to-bound: ~n~a~n~n" relation-to-bound)
    (printf "all-atoms: ~n~a~n~n" all-atoms)
    (printf "total-bounds: ~n~a~n~n" total-bounds)
    (displayln "--------------------------"))

  #| Print to KodKod-CLI
    print configure
    declare univ size
    declare ints
    print Int sig (r0)
    print other sigs (r2 ... rm)
    print succ relation (r(m + 1))
    print other relations (r(m + 2) ... rn)
    print formula / assert formula (f0 ... fk)
    print solve
  |#

  ; Initializing our kodkod-cli process, and getting ports for communication with it
  (define backend (get-option run-spec 'backend))
  (define-values (stdin stdout stderr shutdown is-running?) 
    (cond
      ; if there is an active server state, and the server is running
      [(and (unbox server-state) ((Server-ports-is-running? (unbox server-state))))
       (define sstate (unbox server-state))
       (when (@> (get-verbosity) VERBOSITY_LOW)
        (printf "Pardinus solver process already running. Starting new run with id ~a.~n" run-name))
       (values (Server-ports-stdin sstate) (Server-ports-stdout sstate) 
               (Server-ports-stderr sstate) (Server-ports-shutdown sstate)
               (Server-ports-is-running? sstate))]
      [(equal? backend 'kodkod)
       (raise "Pure Kodkod backend is no longer supported; please use Pardinus backend.")]
      [(equal? backend 'pardinus)
       (when (@>= (get-verbosity) VERBOSITY_HIGH)
         (printf "Starting/restarting Pardinus server (prior state=~a)...~n" (unbox server-state)))
       (pardinus:start-server
        'stepper ; always a stepper problem (there is a "next" button)
        ; 'default, 'temporal, or 'target (tells Pardinus which solver to load,
        ;  and affects parsing so needs to be known at invocation time)
        (get-option run-spec 'problem_type))]
      [else (raise (format "Invalid backend: ~a" backend))]))

  ; (define-syntax-rule (kk-print lines ...)
  ;   (kodkod:cmd 
  ;     [stdin]
  ;     lines ...))

  ; Print targets
  (define-syntax-rule (pardinus-print lines ...)
    (pardinus:cmd 
      [stdin]
      lines ...))

  ; Confirm that if the user is invoking a custom solver, that custom solver exists
  (define solverspec (cond [(symbol? (get-option run-spec 'solver))
                            (get-option run-spec 'solver)]
                           [else (string-append "\"" (get-option run-spec 'solver) "\"")]))
  (unless (or (symbol? (get-option run-spec 'solver))
              (file-exists? (get-option run-spec 'solver)))
    (raise-user-error (format "option solver specified custom solver (via string): ~a, but file did not exist." 
                              (get-option run-spec 'solver))))
  
  ; Print configure and declare univ size
  ; Note that target mode is passed separately, nearer to the (solve) invocation
  (define bitwidth (get-bitwidth run-spec)) 
  (pardinus-print (pardinus:print-cmd (format "(with ~a" run-name)))
  (pardinus-print
    (pardinus:configure (format ":bitwidth ~a :solver ~a :max-solutions 1 :verbosity ~a :skolem-depth ~a :sb ~a :core-gran ~a :core-minimization ~a :log-trans ~a ~a ~a"                               
                               bitwidth 
                               solverspec
                               (get-option run-spec 'engine_verbosity) ; see the Wiki for levels
                               (get-option run-spec 'skolem_depth)
                               (get-option run-spec 'sb) 
                               (get-option run-spec 'coregranularity)
                               (get-option run-spec 'core_minimization)
                               (get-option run-spec 'logtranslation)
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":min-trace-length ~a" (get-option run-spec 'min_tracelength))
                                   "")
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":max-trace-length ~a" (get-option run-spec 'max_tracelength))
                                   "")))
    (pardinus:declare-univ (length all-atoms)))

  ; Declare ints
  (define num-ints (expt 2 bitwidth))
  (pardinus-print
    (pardinus:declare-ints (range (@- (/ num-ints 2)) (/ num-ints 2)) ; ints
                           (range num-ints)))                        ; indexes

  ; to-tupleset :: List<List<int>>, int -> tupleset
  (define (to-tupleset arity eles)
    (if (empty? eles)
        (if (@= arity 1)
            'none
            (pardinus:product 'none (to-tupleset (sub1 arity) eles)))
        (pardinus:tupleset #:tuples eles)))

  (define (get-atoms rel atom-names)
    (define atoms 
      (for/list ([tup atom-names])
        (for/list ([atom tup])
          (unless (member atom all-atoms)
            (raise (format "atom (~a) not in all-atoms (~a)"
                           atom all-atoms)))
          (index-of all-atoms atom))))
    (define ret (to-tupleset (relation-arity rel) atoms))
    ret)

  (for ([rel (get-all-rels run-spec)]
        [bound total-bounds])
    (pardinus-print
      (pardinus:declare-rel
       (if (node/expr/relation-is-variable rel)
           (pardinus:x (relation-name rel))
           (pardinus:r (relation-name rel)))
        (get-atoms rel (bound-lower bound))
        (get-atoms rel (bound-upper bound)))))

  ; Declare assertions
  (define all-rels (get-all-rels run-spec))

  (define (maybe-alwaysify fmla)
    (if (equal? 'temporal (get-option run-spec 'problem_type))
        (always/info (node-info fmla) fmla)
        fmla))
  
  ; Get and print predicates
  ; If in temporal mode, need to always-ify the auto-generated constraints but not the
  ;   predicates that come from users
  ; !!!
  (define raw-implicit-constraints
    (append (get-sig-size-preds run-spec sig-to-bound)
            (get-relation-preds run-spec)
            (get-extender-preds run-spec)
            relation-constraints
            break-preds))
  (define conjuncts-implicit-constraints
    (apply append (map maybe-and->list raw-implicit-constraints)))
  (define implicit-constraints
    (map maybe-alwaysify conjuncts-implicit-constraints))
  (define explicit-constraints
    (apply append (map maybe-and->list (Run-spec-preds run-spec)))) 
              
  (define run-constraints 
    (append explicit-constraints implicit-constraints))

  ; Run last-minute checks for errors  
  (for-each (lambda (c)
              ;(printf "deparse-constraint: ~a~n" (deparse c))
              (checkFormula run-spec c '() (get-checker-hash)))
            run-constraints)
  ;(when (@>= (get-verbosity) VERBOSITY_LOW)        
  ;  (printf "  Last-checker finished. Beginning to send problem.~n"))
  
  ; Keep track of which formula corresponds to which CLI assert
  ; for highlighting unsat cores. TODO: map back from CLI output
  ; constraints later
  (define core-map (make-hash))
  
  (for ([p run-constraints]
        [assertion-number (in-naturals)])
    (hash-set! core-map assertion-number p)
    (pardinus-print
      (pardinus:print-cmd-cont "(~a " (pardinus:f assertion-number))
      (translate-to-kodkod-cli run-spec p all-rels all-atoms '())
      (pardinus:print-cmd ")")
      (pardinus:assert (pardinus:f assertion-number))))

  ; target-oriented model finding may not impose an initial target, but might
  ; be used just to implement custom "next" strategies
  (when (equal? 'target (get-option run-spec 'problem_type))
    (define target (Run-spec-target run-spec))    
    (when target
      (for ([(rel-name atoms) (Target-instance target)])
        (define relation (hash-ref (get-relation-map run-spec) (symbol->string rel-name)))
        (define sig-or-rel
          (if (@= (relation-arity relation) 1)
              (get-sig run-spec relation)
              (get-relation run-spec relation)))
        
        (pardinus-print
         (pardinus:declare-target 
          (pardinus:r (relation-name relation))
          (get-atoms relation atoms)))))

    ; Always say what mode; admittedly this won't always make sense if untargeted
    ; Conflate "target distance" declared with a concrete target and global mode
    (pardinus-print
     (pardinus:print-cmd "(target-option target-mode ~a)"
                         (if target
                             (Target-distance target)
                             (get-option run-spec 'target_mode)))))

  ; Close the "with" scope.
  (pardinus-print (pardinus:print-cmd ")"))
  (pardinus-print (pardinus:print-eoi))
  ; Wait for the acknowledgement before sending more messages.
  (pardinus:read-ack stdout stderr)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; DO NOT ADD MORE MESSAGES TO PARDINUS AFTER THIS POINT
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define (format-statistics stats)
    (let* ([vars (assoc 'size-variables stats)]
           [prim (assoc 'size-primary stats)]
           [clauses (assoc 'size-clauses stats)]
           [tt (assoc 'time-translation stats)]
           [ts (assoc 'time-solving stats)]
           [tcx (assoc 'time-core stats)]
           [tcstr (if tcx (format " Core min (ms): ~a" tcx) "")])
      (format "#vars: ~a; #primary: ~a; #clauses: ~a~nTransl (ms): ~a; Solving (ms): ~a~a"
              vars prim clauses tt ts tcstr)))
  
  ; Print solve
  (define (get-next-model [mode ""])
    (unless (is-running?)
      (raise-user-error "KodKod server is not running."))
    (pardinus-print (pardinus:solve run-name mode))
    (define result (translate-from-kodkod-cli
                    'run 
                    (pardinus:read-solution stdout stderr) 
                    all-rels 
                    all-atoms))
    
    ; Note on cores: if core granularity is high, Kodkod may return a formula we do not have an ID for
    (define (do-core-highlight nd)
      (define loc (nodeinfo-loc (node-info nd)))
      (when (@>= (get-verbosity) VERBOSITY_LOW)        
        (printf "  Core contained location: ~a~n" (srcloc->string loc)))
      (when (@>= (get-verbosity) VERBOSITY_HIGH)        
        (pretty-print nd)))
;      (if (is-drracket-linked?) 
;          (do-forge-highlight loc CORE-HIGHLIGHT-COLOR 'core)
;          (begin
;            )))

    (when (and (Unsat? result) (Unsat-core result)) ; if we have a core
      (when (@>= (get-verbosity) VERBOSITY_DEBUG)
        (printf "core-map: ~a~n" core-map)
        (printf "core: ~a~n" (Unsat-core result)))
      (cond ;[(is-drracket-linked?) 
        ; (do-forge-unhighlight 'core)]
        [else
         (when (@>= (get-verbosity) VERBOSITY_LOW) 
           (printf "No DrRacket linked, could not highlight core. Will print instead.~n"))])
      (for-each do-core-highlight
                (filter-map (λ (id)
                              (let ([fmla-num (if (string-prefix? id "f:") (string->number (substring id 2)) #f)])
                                (cond [(member fmla-num (hash-keys core-map))
                                       ; This is a formula ID and we know it
                                       ;(printf "LOC: ~a~n" (nodeinfo-loc (node-info (hash-ref core-map fmla-num))))
                                       (hash-ref core-map fmla-num)]
                                      [else
                                       ; This is NOT a known formula id, but it's part of the core
                                       (printf "WARNING: Core also contained: ~a~n" id)
                                       #f])))
                            (Unsat-core result))))
    
    (when (@>= (get-verbosity) VERBOSITY_LOW)
      (displayln (format-statistics (if (Sat? result) (Sat-stats result) (Unsat-stats result)))))
    result)

  (define (next-button type)
    (tree:make-node (get-next-model type) next-button))
  (define results
    (tree:make-node (get-next-model 'start) next-button))

  (set-box! server-state (Server-ports stdin stdout stderr shutdown is-running?))

  (values results 
          all-atoms 
          (unbox server-state)
          (Kodkod-current (length run-constraints) 0 0) 
          total-bounds))


(define (get-bounds run-spec raise-run-error)
  ; Send user defined partial bindings to breaks
  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))

  ; Get KodKod names, min sets, and max sets of Sigs and Relations
  (define-values (sig-to-bound all-atoms) ; Map<Symbol, bound>, List<Symbol>
    (get-sig-bounds run-spec raise-run-error))

  (define relation-to-bound ; Map<Symbol, bound>
    (get-relation-bounds run-spec sig-to-bound raise-run-error))

  (values sig-to-bound relation-to-bound all-atoms))


; get-sig-info :: Run-spec -> Map<Symbol, bound>, List<Symbol>
; Given a Run-spec, assigns names to each sig, assigns minimum and maximum 
; sets of atoms for each, and find the total number of atoms needed (including ints).
(define (get-sig-bounds run-spec raise-run-error)
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))  
  (define (get-bound-lower sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding ;; !!!
          (map car (set->list (sbound-lower pbinding)))))
  (define (get-bound-upper sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding
          (sbound-upper pbinding)
          (map car (set->list (sbound-upper pbinding)))))

  (define scopes (Run-spec-scope run-spec))
  (define (get-scope-lower sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-lower scope)))
  (define (get-scope-upper sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-upper scope)))
  (define (get-scope-lower-default sig)
    (let ([actual (get-scope-lower sig)])
      (or actual
          (Range-lower (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))
  (define (get-scope-upper-default sig)
    (let ([actual (get-scope-upper sig)])
      (or actual
          (Range-upper (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))



  ; Map<Symbol, int>
  (define curr-atom-number (make-hash))
  ; Sig -> Symbol
  (define all-user-atoms 
    (apply append (for/list ([sig (get-sigs run-spec)]
                             #:when (hash-has-key? pbindings sig))
      (define bound (hash-ref pbindings sig))
      (map car (set->list (@or (sbound-upper bound) (sbound-lower bound)))))))
  (define (get-next-name sig)
    (define atom-number (add1 (hash-ref curr-atom-number (Sig-name sig) -1)))    
    (let loop ([atom-number atom-number])
      (hash-set! curr-atom-number (Sig-name sig) atom-number)
      (define new-name (string->symbol (format "~a~a" (Sig-name sig) atom-number)))
      (if (member new-name all-user-atoms)
          (loop (add1 atom-number))
          new-name)))
    
;    (if (hash-has-key? tbindings (Sig-name sig))
;        (let ([bind-names (hash-ref tbindings (Sig-name sig))])                 
;          (if (@< atom-number (length bind-names))
;              (list-ref bind-names atom-number)
;              (if (member default-name bind-names) ; Avoid clash with user atom names
;                  (get-next-name sig)
;                  default-name)))          
  ;)
  
  ; Sig, int -> List<Symbol>
  ; TN changed this to always use the *lowest* unused atom names first
  ;   this matters if we're manufacturing an instance I2 from an instance I1 and the bounds
  ;   need to be identical regardless of how many of a given sig appeared in I1.
  ; (define (get-next-names sig num)
  ;   (define bind-names (if (hash-has-key? tbindings (Sig-name sig))
  ;                          (hash-ref tbindings (Sig-name sig))  ; user-defined names    
  ;                          empty))
  ;   (define default-names (for/list ([_ (range num)]) (get-next-name sig)))
  ;   (define new-names (remove* bind-names default-names)) ; (remove* v-lst lst) removes from lst every element of v-lst
  ;   (define n-new-needed (- num (length bind-names)))

  ;   (append bind-names (if (@> n-new-needed 0) (take new-names n-new-needed) empty)))
  (define (generate-names sig num)
    (map (thunk* (get-next-name sig)) (range num)))



  (define lower-bounds (make-hash))
  (define upper-bounds (make-hash))

  ; If any #:one children lack tuple-based lower bounds, there is a risk of inconsistency
  ; since those children must receive a fresh atom name to denote (and for #:one sigs, LB=UB)
  (define (fill-lower-by-bound sig)
    (define children-lowers
      (apply append (map fill-lower-by-bound (get-children run-spec sig))))
    (define curr-lower (get-bound-lower sig))
    (when (and (not curr-lower) (Sig-one sig))
      (raise-run-error (format "Instance block named members for an ancestor of 'one' sig ~a but no member name was given for ~a. This can result in inconsistency; please give bounds for ~a." (Sig-name sig) (Sig-name sig) (Sig-name sig))))
    (define true-lower
      (remove-duplicates
        (append children-lowers
                (@or curr-lower (list)))))    
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-lower-by-scope sig)
    (define children-lowers
      (apply append (map fill-lower-by-scope (get-children run-spec sig))))
    (define curr-lower-bound (get-bound-lower sig))
    (define curr-lower-scope (get-scope-lower-default sig))
    (define true-lower
      (remove-duplicates
        (if curr-lower-bound
            (append curr-lower-bound children-lowers)
            (append (generate-names sig (@- curr-lower-scope (length children-lowers))) children-lowers))))
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-upper-with-bound sig [parent-upper #f])
    (define curr-upper (get-bound-upper sig))
    (if curr-upper
        (let ()
          (hash-set! upper-bounds sig curr-upper)
          (map (lambda (child) (fill-upper-with-bound child curr-upper))
               (get-children run-spec sig)))
        (fill-upper-past-bound sig parent-upper)))

  (define (fill-upper-past-bound sig parent-upper)
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))))
    (hash-set! upper-bounds sig parent-upper)
    (map (lambda (child) (fill-upper-past-bound child parent-upper))
         (get-children run-spec sig)))

  ; For use in situations where there is no existing upper (relational) bound
  (define (fill-upper-no-bound sig shared)
    ; If the sig has a relational upper bound, don't try to resolve the possible
    ; atom names etc.; ask the user to give an explicit bound on the parent, too.
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))))
    (define curr-lower (hash-ref lower-bounds sig))
    ; If the upper-bound's scope is bigger than the lower bound's current contents
    ;   (which should include child sigs' lower bounds), make room using atoms from parent.
    ; Otherwise, upper = lower, since there is no excess capacity.
    (if (@> (get-scope-upper-default sig) (length curr-lower))
        (hash-set! upper-bounds sig (append curr-lower shared))
        (hash-set! upper-bounds sig curr-lower))
    ; Recur on children
    (map (lambda (child) (fill-upper-no-bound child (append curr-lower shared)))
         (get-children run-spec sig)))
  
  (define sig-atoms (list))
  (for ([root (get-top-level-sigs run-spec)]
        #:unless (equal? (Sig-name root) 'Int))
    (if (get-bound-upper root) ; Do we already have a tuple-based upper bound?
        (let ()           
          (fill-lower-by-bound root)
          (fill-upper-with-bound root))           
        (let ()
          (fill-lower-by-scope root) ; No tuple-based bound yet; extrapolate from scope
          (define lower-size (length (hash-ref lower-bounds root)))
          (define upper-size
            (or (get-scope-upper root)
                (@max lower-size
                      (get-scope-upper-default root))))

          (define shared (generate-names root (@- upper-size lower-size)))
          (fill-upper-no-bound root shared)))
    ;(printf "filling bounds at ~a; upper = ~a; lower = ~a~n" root upper-bounds lower-bounds)
    (set! sig-atoms (append sig-atoms (hash-ref upper-bounds root))))

  ; Set the bounds for the Int built-in sig
  (define int-atoms
    (let* ([bitwidth (get-bitwidth run-spec)]
           [max-int (expt 2 (sub1 bitwidth))])
      (range (@- max-int) max-int)))
  (hash-set! lower-bounds (get-sig run-spec Int) int-atoms)
  (hash-set! upper-bounds (get-sig run-spec Int) int-atoms)

  ; Special case: allow sigs to extend Int
  (for ([sig (get-children run-spec Int)])
    (hash-set! lower-bounds (Sig-name sig) '())
    (hash-set! upper-bounds (Sig-name sig) int-atoms))  

  (define all-atoms (append int-atoms sig-atoms))

  ; Map<Symbol, bound>
  (define bounds-hash
    (for/hash ([sig (get-sigs run-spec)])
      (let* ([name (Sig-name sig)]
             [rel sig]
             [lower (map list (hash-ref lower-bounds sig))]
             ; Override generated upper bounds for #:one sigs
             [upper
              (cond [(Sig-one sig) lower]
                    [else (map list (hash-ref upper-bounds sig))])])
        ;(printf "bounds-hash at ~a; lower = ~a; upper = ~a; non-one upper = ~a~n" rel lower upper (hash-ref upper-bounds sig))                            
        (unless (subset? (list->set lower) (list->set upper))
          (raise-run-error (format "Bounds inconsistency detected for ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Sig-name sig) lower upper)))
        (values name (bound rel lower upper)))))

;; Issue: one sig will overwrite with lower bound, but looking like that's empty if there's 
;;   an inst block that doesnt define it. Need to make that connection between default and provided.
;;   TODO  

  (values bounds-hash all-atoms))

; get-relation-info :: Run-spec -> Map<Symbol, bound>
; Given a Run-spec, the atoms assigned to each sig, the atoms assigned to each name,
; and the starting relation name, assigns names to each relation
; and minimum and maximum sets of atoms for each relation.
(define (get-relation-bounds run-spec sig-to-bound raise-run-error)
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))
  (define piecewise (Bound-piecewise (Run-spec-bounds run-spec)))
  
  (define (get-bound-lower rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-lower pbinding)))
  (define (get-bound-upper rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-upper pbinding)
          (sbound-upper pbinding)))
  (define (get-bound-piecewise rel)
    (hash-ref piecewise rel #f))

  (define without-succ
    (for/hash ([relation (get-relations run-spec)]
               #:unless (equal? (Relation-name relation) 'succ))
      (define sigs (get-sigs run-spec relation))
      (define sig-atoms (map (compose (curry map car )
                                      bound-upper
                                      (curry hash-ref sig-to-bound )
                                      Sig-name) 
                             sigs))
       ;(printf "~a: sig-atoms : ~a~n" relation sig-atoms)
       ;(printf "~a: raw upper : ~a~n" relation (get-bound-upper relation))
       ;(printf "~a: raw lower : ~a~n" relation (get-bound-lower relation))
      
      (define upper                   
        (let ([bound-upper (get-bound-upper relation)]
              [bound-piecewise (get-bound-piecewise relation)])
          (cond
            [(and bound-piecewise bound-upper)
             ; Error condition -- should never have both complete and piecewise on the same relation
             (raise (error (format "~a upper-bound had both complete and piecewise components, could not resolve them."
                                   relation)))]
            [bound-piecewise
             ; for each admissible atom (taken from first component of the relation's declaration):
             ;   Where a piecewise entry exists: intersect with cartesian product of restricted universe.
             ;   otherwise: include the full cartesian-product for the restriction outside of that domain
             (define pw-domain (PiecewiseBound-atoms bound-piecewise))
             ;(printf "upper; pw-domain: ~a~n" pw-domain) ; ISSUE: this is pre-eval :/ store post-eval?
             (define in-domain (set-intersect (list->set (PiecewiseBound-tuples bound-piecewise))
                                              (list->set (apply cartesian-product sig-atoms))))
             ;(printf "upper; in-domain: ~a~n" in-domain)
             (define out-of-domain (list->set
                                    (filter (lambda (tup)
                                              (not (member (first tup) pw-domain)))
                                            (apply cartesian-product sig-atoms))))
             ;(printf "upper; out-of-domain: ~a~n" out-of-domain)
             (set->list (set-union in-domain out-of-domain))]
            [bound-upper
             ; complete upper bound exists; intersect with the cartesian product of universe
             ; restricted to the sig-sequence in relation's declaration
             (set->list (set-intersect bound-upper
                                       (list->set (apply cartesian-product sig-atoms))))]
            [else
             ; no upper-bound given, default to cartesian product of universe, restricted
             ; to the sig-sequence in relation's declaration
             (apply cartesian-product sig-atoms)])))
      
      ;(define upper (set->list (set-intersect (get-bound-upper relation) (list->set (apply cartesian-product sig-atoms)))))
      ;(printf "~a: refined upper : ~a~n" relation upper)

      ; Piecewise lower bounds were handled in sigs-functional, before send-to-kodkod is called.
      (define lower                   
        (let ([bound-lower (get-bound-lower relation)])
            (if bound-lower
                (set->list (set-union bound-lower (list->set empty)))
                (list->set empty))))      
      ;(define lower (set->list (set-union (get-bound-lower relation) (list->set empty))))

      (unless (subset? (list->set lower) (list->set upper))
        (raise-run-error (format "Bounds inconsistency detected for field ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Relation-name relation) lower upper)))
      
      (values (Relation-name relation) 
              (bound relation lower upper))))
  
  (define ints (map car (bound-upper (hash-ref sig-to-bound 'Int))))
  (define succ-tuples (map list (reverse (rest (reverse ints))) (rest ints)))
  (hash-set without-succ 'succ (bound succ succ-tuples succ-tuples)))

; get-sig-size-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig to restrict
; it to the correct lower/upper bound.
(define (get-sig-size-preds run-spec sig-to-bound) 
  (define max-int (expt 2 (sub1 (get-bitwidth run-spec))))
  (apply append
    (for/list ([sig (get-sigs run-spec)]
               #:unless (equal? (Sig-name sig) 'Int))
      (match-define (bound rel bound-lower bound-upper) (hash-ref sig-to-bound (Sig-name sig)))
      (define-values (bound-lower-size bound-upper-size) (values (length bound-lower) (length bound-upper)))
      (match-define (Range int-lower int-upper) 
        (hash-ref (Scope-sig-scopes (Run-spec-scope run-spec)) (Sig-name sig) (Range #f #f)))
      
      (append
        (if (@and int-lower (@> int-lower bound-lower-size))
            (let ()
              (unless (@< int-lower max-int)
                (raise (format (string-append "Lower bound too large for given BitWidth; "
                                              "Sig: ~a, Lower-bound: ~a, Max-int: ~a")
                               sig int-lower (sub1 max-int))))
              (list (int<= (int int-lower) (card sig))))
            (list))
        (if (@and int-upper (@< int-upper bound-upper-size))
            (let ()
              (unless (@< int-upper max-int)
                (raise (format (string-append "Upper bound too large for given BitWidth; "
                                              "Sig: ~a, Upper-bound: ~a, Max-int: ~a")
                               sig int-upper (sub1 max-int))))
              (list (int<= (card sig) (int int-upper))))
            (list))))))


; TN TODO
; For many implicit constraints, it's either difficult or impossible to
; produce a *single* location to blame the formula on. For instance,
; the constraint that forces two sigs to be disjoint from one another
; can't be blamed solely on one of the two sigs.
; Instead, keep track of lists of sites for each implicit formula.

; get-extender-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig which has extending Sigs so that:
; - if it is abstract, then it must equal the sum of its extenders
; -                    else it must contain the sum of its extenders
; - all extenders are pair-wise disjoint.
(define (get-extender-preds run-spec)
  (define sig-constraints (for/list ([sig (get-sigs run-spec)])
    ; get children information
    (define children-rels (get-children run-spec sig))

    ; abstract and sig1, ... extend => (= sig (+ sig1 ...))
    ; not abstract and sig is parent of sig1 => (in sig1 sig)
    ; TODO: optimize by identifying abstract sigs as sum of children
    (define (abstract sig extenders)
      ; TODO : location not correct
      (let ([loc (nodeinfo-loc (node-info sig))])
        (if (@= (length extenders) 1)
            (=/info (nodeinfo loc 'checklangNoCheck) sig (car extenders))
            (=/info (nodeinfo loc 'checklangNoCheck) sig (+ extenders)))))
    (define (parent sig1 sig2)
      ; loc of sig2?
      (let ([loc (nodeinfo-loc (node-info sig2))])
        (in/info (nodeinfo loc 'checklangNoCheck) sig2 sig1)))

    (define extends-constraints 
      (if (and (Sig-abstract sig) (cons? (get-children run-spec sig)))
          (list (abstract sig children-rels))
          (map (curry parent sig) children-rels)))

    ; sig1 and sig2 extend sig => (no (& sig1 sig2))
    ; (unless both are #:one, in which case exact-bounds should enforce this constraint)
    (define (disjoin-pair sig1 sig2)
      (let ([loc (nodeinfo-loc (node-info sig2))])
        (cond [(and (Sig-one sig1) (Sig-one sig2))
               true]
              [else
               (no (&/info (nodeinfo loc 'checklangNoCheck) sig1 sig2))])))
    (define (disjoin-list a-sig a-list)
      (map (curry disjoin-pair a-sig) a-list))
    (define (disjoin a-list)
      (if (empty? a-list)
          empty
          (append (disjoin-list (first a-list) (rest a-list))
                  (disjoin (rest a-list)))))
    (define disjoint-constraints (disjoin children-rels))

    (append extends-constraints disjoint-constraints)))

  ; combine all constraints together
  (apply append sig-constraints))

; get-relation-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Relation to ensure that it does not
; contain any atoms which don't populate their Sig.
(define (get-relation-preds run-spec)
  (for/list ([relation (get-relations run-spec)])
    (define sig-rels (get-sigs run-spec relation))
    (in relation (-> sig-rels))))

#|

Algorithm (draft) for bound generation:

lowerBound1(sig)
    (explicit lower bound or {}) union
    union of lowerBound(sig.children)

lowerBound2(sig)
    if sig has lower tuple bound
        lower tuple bound union union of lowerBound(sig.children)
    else
        union of lowerBound(sig.children) + generate names to make lower scope of sig


fillUpper1(current, [parentUpper #f]):
    if partialBounds.upper has current
        current.upper = partialBounds.upper(current)
        map fillUpper1(_, current.upper) onto current.children
    else
        fillUpper2(current, parentUpper)

fillUpper2(current, parentUpper):
    assert partialBounds.upper not has current
    current.upper = parentUpper
    map fillUpper2(_, current.upper) onto current.children

fillUpper3(current, shared):
    assert partialBounds.upper not has current
    current.upper = current.lower + shared
    map fillUpper3(_, shared) onto current.children

for root in root sigs
    if root has tuple upper bound
        fillUpper1(root)

    else (root does not have tuple upper bound)
        upperSize = 
            root's numerical upper bound, if present
            maximum of #root.lower and default upper

        shared = generate(upperSize - #root.lower)
        fillUpper3(root, shared)

|#
